# 分布式锁

逻辑

* 判断锁变量的值，根据变量值来判断能否加锁成功
* 释放锁时需要把锁变量值设置为0，表明客户端不再持有锁


要求

* 要求1：分布式锁的加锁和释放锁的过程涉及多个操作。在实现分布式锁时需要保证这些操作的原子性
* 要求2：实现分布式锁时，需要保证共享存储系统的可靠性，进而保证锁的可靠性

## 基于单个节点实现分布式锁
-------

### 使用SETNX命令

```
SETNX key value
```

这个命令在执行时会判断键值对是否存在，如果不存在，就设置键值对的值，如果存在，就不做任何设置

```
// 加锁
SETNX lock_key 1
// 业务逻辑
DO THINGS
// 释放锁
DEL lock_key
```

### 问题

* 为了避免客户端加锁后崩溃导致锁无法被释放，需要给锁变量设置一个过期时间
* 为了避免客户端A的锁被客户端B释放，需要区分来自不同客户端的锁操作

### 使用SET命令

```
SET key value [EX seconds | PX milliseconds] [NX]
```
* NX选项：不存在则创建 Not eXist
* EX/PX选项：设置键值对过期时间 EX:秒  PX:毫秒

#### 加锁
```
SET lock_key unique_value NX PX 10000
```
unique_value是客户端唯一标识，可使用随机字符串，PX 10000表示lock_key 10秒后过期

#### 释放锁

释放锁操作的逻辑包含读取锁变量，判断值，删除锁变量的多个操作；Redis执行lua脚本时能够以院子性的方式执行，所以这里需要使用lua脚本来保证锁释放的原子性。
```
// Lua 脚本（unlock.script）伪代码
// 释放锁 比较unique_value是否相等，避免误释放
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```
lua脚本中KEYS[1]表示lock_key, ARGV[1]是当前客户端的唯一标识, 这两个值都需要在执行lua脚本时作为参数传入

执行以下命令即可完成锁释放操作

```
redis-cli  --eval  unlock.script lock_key , unique_value 
```

## 基于多个Redis节点实现高可靠的分布式锁
--------

避免Redis实例故障导致锁无法工作的问题

### 分布式锁算法Redlock

基本思路：
* 让客户端和多个独立的Redis实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么就能够认为客户端成功地获得分布式锁，否则加锁失败

步骤：
1. 客户端获取当前时间
2. 客户端按顺序依次向N个Redis实例执行加锁操作
   1. 操作同单节点加锁
   2. 需要给加锁操作设置超时时间
   3. 超时后直接向下一个实例发送请求
   4. 超时时间因远小于锁有效时间，一般设置为几十毫秒
3. 一旦客户端完成了和所有的Redis实例的加锁操作，客户端需要计算整个加锁过程总耗时
4. 判断加锁释放成功
   1. 客户端从超过半数（>= N/2+1）的Redis实例上成功获取到了锁
   2. 客户端获取锁的总耗时没有超过锁的有效时间
5. 计算锁有效时间（锁最初有效时间-客户端为获取锁总耗时），锁有效时间不够完成数据操作则释放


